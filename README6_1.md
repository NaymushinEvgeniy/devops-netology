# Домашнее задание к занятию "6.1. Типы и структура СУБД"

### Задача 1

Архитектор ПО решил проконсультироваться у вас, какой тип БД лучше выбрать для хранения определенных данных.

Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:

- Электронные чеки в json виде

Документоориентированные NoSQL БД (MongoDB)
Высокопроизводительная БД (что важно для элеткронной коммерции) адаптированная под хранение данных в формате JSON

- Склады и автомобильные дороги для логистической компании

Объектно-ориентированные БД
В отсутсвии требований взаимосвязонности этих данных отлично подойдут для их предстваления в виде объектов

- Генеалогические деревья

Иерархические БД
По своей структуре полность повторяют заявленную модель данных с достатчно важным свойством в виде однозначного 
определения объекта - предка по отношению к объекту/объектам потомков

- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации

NoSQL БД
Высокопроизводительные БД(что достачно важно для механизмов авторизации), широко распространенные в технология 
кеширования с особенностями в виде ограниченного времени хранения

- Отношения клиент-покупка для интернет-магазина

Реляционные БД
Наиболее подходящий вариант для хранения критически важных данных (клиенты, покупки клиентов) с механизмом связи 
между заданными наборами данных

### Задача 2

Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно CAP-теореме. Какой 
классификации по CAP-теореме соответствует ваша система, если (каждый пункт - это отдельная реализация вашей системы и 
для каждого пункта надо привести классификацию):

Данные записываются на все узлы с задержкой до часа (асинхронная запись)
При сетевых сбоях, система может разделиться на 2 раздельных кластера
Система может не прислать корректный ответ или сбросить соединение
А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

1. Данные записываются на все узлы с задержкой до часа (асинхронная запись):
Система всегда доступна, но данные в ответе узлов могут отличаться - они не согласованы, но доступны и устойчивы к 
разделению (узлы между собой не общаются либо с большим таймаутом, либо не общаются совсем).
Пример - разделенная БД 1С.
В центральном офисе может располагаться центральный экземпляр узла БД, в филиалах расположены распределенные узлы.
Базы периодически синхронизируются (например обмен XML-файлами обмена по FTP)
Согласно PACELC: При сетевом разделении, эти базы доступны и не консистентные, в случае отсутствия разделения (например 
базы синхронизируются в текущий момент) приоритеты не понятны, так что может быть как EL так и EC хотя подсознательно 
ближе к тому, что система будет бороться за время ответа.

2. При сетевых сбоях, система может разделиться на 2 раздельных кластера
На сомом деле, разделение кластера на 2 узла это как раз и является Partition Tolerance - та как система в первую очередь остаться живой, и случае каких то проблем будет отвечать всегда,  и даже если кластер развалится, то отдельные узлы будут отвечать, но естественно не согласованно. Отказаться от PT (а значит, выбрать C и A) значит полагать, что система имеет идеальную связь и никогда не теряет сообщения между своими частями - в нашем случае это не так. 
PACELC: При сетевом разделении, базы доступны. но не консистентные,  в  случае отсутствия разделения (Например базы синхронизируются в текущий момент) приоритеты не понятны, так что может быть как EL так и EC

3. Система может не прислать корректный ответ или сбросить соединение:
Если система не присылает ответ или сбрасывает соединение - значит у нее какие то проблемы. Если система живая, но часть узлов отвалилось, она решает просто игнорировать вопрошающих, что бы не дай бог не дать несогласованные данные.  Некорректный ответ это например код возврата c описанием проблемы кластера ну или при запросе БД разрывает соединение - Ну по факту, она же отвечает. Но отрицательный результат - тоже результат. А вот Partition Tolerance она жертвует. 
Напоминаю, что отказаться от PT (а значит, выбрать C и A) значит полагать, что система имеет идеальную связь и никогда не теряет сообщения между своими частями - в нашем случае мы считаем именно так
Если бы вместо ответа был бы падение по таймауту, то тут уже явная жертва доступности, но ее тут нет). Подразумевается, что ИБ все таки отвечает, но не так как бы нам хотелось(
PACELC: При сетевом разделении, базы не доступны. но консистентные,  в  случае отсутствия разделения скорее всего будут готовы к задержкам, но сохранить консистентность - примеры  VoltDB/H-Store и Megastore

